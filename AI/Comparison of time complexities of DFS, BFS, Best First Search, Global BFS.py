# -*- coding: utf-8 -*-
"""191118 Moin ud din Lab Task 5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oS-0fARp5cViVbuzopja_hwjuNNDIkx1
"""

import numpy as np
import pandas as pd
from time import time
import matplotlib.pyplot as plt

"""### Combining it all """

class Puzzle:
    goal_state = [1,2,3,
                  8,0,4,
                  7,6,5]
    heuristic=None
    evaluation_function=None
    needs_hueristic=True
    num_of_instances=0
    def __init__(self,state,parent,action,path_cost,needs_hueristic=False):
        self.parent=parent
        self.state=state
        self.action=action
        if parent:
            self.path_cost = parent.path_cost + path_cost
        else:
            self.path_cost = path_cost
        if needs_hueristic:
            self.needs_hueristic=True
            self.MisplacedTiles()
            self.evaluation_function=self.heuristic+self.path_cost
        Puzzle.num_of_instances+=1

    def __str__(self):
        return str(self.state[0:3])+'\n'+str(self.state[3:6])+'\n'+str(self.state[6:9])

    def generate_heuristic(self):
        self.heuristic=0
        for num in range(1,9):
            distance=abs(self.state.index(num) - self.goal_state.index(num))
            i=int(distance/3)
            j=int(distance%3)
            self.heuristic=self.heuristic+i+j

    def ManhattanDistance(self):
      self.heuristic = 0
      for i in range(len(self.goal_state)):
        ind = list(self.goal_state).index(self.state[i])
        if (ind != i):
          row_goal = int(i/3)
          row_ini = int(ind/3)
          col_goal = i%3
          col_ini = ind%3
          self.heuristic = self.heuristic + abs(row_goal - row_ini) + abs(col_goal - col_ini)
      

    def goal_test(self):
        if self.state == self.goal_state:
            return True
        return False

    @staticmethod
    def find_legal_actions(i,j):
        legal_action = ['U', 'D', 'L', 'R']
        if i == 0:  # up is disable
            legal_action.remove('U')
        elif i == 2:  # down is disable
            legal_action.remove('D')
        if j == 0:
            legal_action.remove('L')
        elif j == 2:
            legal_action.remove('R')
        return legal_action


    def MisplacedTiles(self):
      self.heuristic = 0
      for i in range(len(self.goal_state)):
        if self.goal_state[i] != self.state[i]:
          self.heuristic = self.heuristic + 1


    def generate_child(self):
        children=[]
        x = self.state.index(0)
        i = int(x / 3)
        j = int(x % 3)
        legal_actions=self.find_legal_actions(i,j)

        for action in legal_actions:
            new_state = self.state.copy()
            if action is 'U':
                new_state[x], new_state[x-3] = new_state[x-3], new_state[x]
            elif action is 'D':
                new_state[x], new_state[x+3] = new_state[x+3], new_state[x]
            elif action is 'L':
                new_state[x], new_state[x-1] = new_state[x-1], new_state[x]
            elif action is 'R':
                new_state[x], new_state[x+1] = new_state[x+1], new_state[x]            
            children.append(Puzzle(new_state,self,action,1,self.needs_hueristic))
        return children

    def find_solution(self):
        solution = []
        solution.append(self.action)
        path = self
        while path.parent != None:
            path = path.parent
            solution.append(path.action)
        solution = solution[:-1]
        solution.reverse()
        return solution

"""### Using above Class in Breadth First Search"""

from queue import Queue

def breadth_first_search(initial_state):
    start_node = Puzzle(initial_state, None, None, 1)
    if start_node.goal_test():
        return start_node.find_solution()
    q = Queue()
    q.put(start_node)
    explored=[]
    while not(q.empty()):
        node=q.get()
        explored.append(node.state)
        children=node.generate_child()
        for child in children:
            if child.state not in explored:
                if child.goal_test():
                    return child.find_solution()
                q.put(child)
    return

from queue import Queue

def best_first_search(initial_state):
    start_node = Puzzle(initial_state, None, None, 1)
    if start_node.goal_test():
        return start_node.find_solution()
    q=[] 
    q.append(start_node) 
    explored=[]
    while (len(q)>0):
        node=q.pop()
        explored.append(node.state)
        children=node.generate_child()
        for child in children:
            if child.state not in explored:
                if child.goal_test():
                    return child.find_solution()
      
        for i in range(len(children)):
          for j in range(len(children)):
            if children[i].heuristic < children[j].heuristic:
              temp  = children[i]
              children[i] = children[j]
              children[j] = temp

        if child.state not in explored:
          q.append(child)
    return

def depth_first_search(initial_state):
  start_node= Puzzle(initial_state, None, None, 0)
  if start_node.goal_test():
    return start_node.find_solution()
  q=[] 
  q.append(start_node) 
  explored=[]
  while (len(q)>0):
    last_node = q.pop()
    explored.append(last_node.state) 
    children=last_node.generate_child()
    
    
    for child in children:
            if child.state not in explored:
                if child.goal_test():
                    return child.find_solution()
                q.append(child)
    return

from queue import Queue


def global_best_first_search(initial_state):
    start_node = Puzzle(initial_state, None, None, 1)
    if start_node.goal_test():
        return start_node.find_solution()
    q = Queue()
    q.put(start_node)
    explored=[]
    while not(q.empty()):
        node=q.get()
        explored.append(node.state)
        children=node.generate_child()
        for child in children:
            if child.state not in explored:
                if child.goal_test():
                    return child.find_solution()

        for i in range(len(children)):
          for j in range(len(children)):
            if children[i].heuristic < children[j].heuristic:
              temp  = children[i]
              children[i] = children[j]
              children[j] = temp

        for child in children:
            if child.state not in explored:
                q.put(child)
    return

"""### Main Function"""

from time import time

state=[[1, 3, 4, 
        8, 6, 2, 
        7, 0, 5],

       [2, 8, 1,
        0, 4, 3,
        7, 6, 5],

       [2, 8, 1,
        4, 6, 3,
        0, 7, 5]
      ]

for i in range(0,1):
    # Depth First Search
    Puzzle.num_of_instances=0
    t0 = time()
    temp = depth_first_search(state[i])
    t1 = time()-t0
    s1 = Puzzle.num_of_instances

    # Breadth First Search
    Puzzle.num_of_instances=0
    t0 = time()
    temp = breadth_first_search(state[i])
    t2 = time()-t0
    s2 = Puzzle.num_of_instances

    # Best First Search
    Puzzle.num_of_instances=0
    t0 = time()
    temp = best_first_search(state[i])
    t3 = time()-t0
    s3 = Puzzle.num_of_instances

    # Global Best First Search
    Puzzle.num_of_instances=0
    t0 = time()
    temp = global_best_first_search(state[i])
    t4 = time()-t0
    s4 = Puzzle.num_of_instances

    from tabulate import tabulate

    data = [
            ["Depth First Search", s1, t1], 
            ["Breadth First Search", s2, t2], 
            ["Best First Search", s3, t3], 
            ["Global Best First Search", s4, t4]
            ]
  
    #define header names
    col = ["Name of search method", "Space complexity", "Time complexity"]
      
    #display table
    print(tabulate(data, headers=col, tablefmt="fancy_grid"))

